# Backend Documentation

This document provides comprehensive documentation for the Jojo TTRPG Platform backend, detailing its architecture, core functionalities, and key processes.

## 1. Backend Architecture: How and Why It Works

The Jojo TTRPG Platform backend is built using **Django**, a high-level Python web framework, and **Django REST Framework (DRF)**, a powerful and flexible toolkit for building Web APIs. This combination provides a robust and scalable foundation for managing game data and serving it to the frontend.

**Key Components:**

*   **Django Core**: Handles URL routing, database interactions (ORM), authentication, and administrative interfaces.
*   **Django REST Framework**: Facilitates the creation of RESTful APIs, providing serializers for data representation, viewsets for handling common API logic (CRUD operations), and authentication/permission mechanisms.
*   **Database**: Currently uses SQLite (`db.sqlite3`) for development, as configured in `backend/src/app/settings.py`. This can be easily swapped for more robust production databases like PostgreSQL.
*   **Installed Apps**: The `backend/src/app/settings.py` file lists the installed Django applications. The primary custom application is `characters`, which encapsulates the core game logic and data models. Other important apps include `rest_framework` and `corsheaders` for API functionality and cross-origin resource sharing.

**API Design Principles:**

The API follows RESTful principles, exposing resources (e.g., characters, stands, campaigns) through clear and consistent URLs. DRF's `ModelViewSet`s are extensively used to provide standard CRUD (Create, Retrieve, Update, Delete) operations for these resources.

**URL Structure (from `backend/src/app/urls.py`):**

The `urls.py` defines the API endpoints. A `DefaultRouter` from DRF automatically generates URL patterns for the registered `ViewSet`s. Key API endpoints include:

*   `/api/heritages/`: Manage character heritages.
*   `/api/vices/`: Manage character vices.
*   `/api/abilities/`: Manage general abilities.
*   `/api/stands/`: Manage Stands.
*   `/api/stand-abilities/`: Manage Stand-specific abilities.
*   `/api/hamon-abilities/`: Manage Hamon-specific abilities.
*   `/api/spin-abilities/`: Manage Spin-specific abilities.
*   `/api/characters/`: Manage player characters.
*   `/api/campaigns/`: Manage game campaigns.
*   `/api/npcs/`: Manage Non-Player Characters.
*   `/api/crews/`: Manage player crews.
*   `/api/traumas/`: Manage character traumas.
*   `/api/search/`: Global search functionality.
*   `/api/get_available_playbook_abilities/`: Endpoint to retrieve abilities based on playbooks.
*   `/api/docs/`: API documentation (likely generated by DRF's schema views).
*   `/api/accounts/login/`: User login endpoint.
*   `/api/accounts/signup/`: User registration endpoint.

This architecture allows for a clear separation of concerns, with the backend focusing on data management, business logic, and API exposure, while the frontend consumes these APIs to provide the user interface.

## 2. Character Creation Process

Player character (PC) creation is a multi-faceted process that involves defining a character's core attributes, selecting abilities, and establishing their unique traits. The backend enforces a strict set of rules, largely derived from the SRD, to ensure character validity and balance.

### 2.1. Core Models

The primary models involved in character creation are:

*   **`Character`**: (defined in `backend/src/characters/models.py`) Represents the player character itself, holding fields for personal details, action dots, heritage, vice, stress, trauma, and various advancement trackers.
*   **`Stand`**: (defined in `backend/src/characters/models.py`) Linked via a `OneToOneField` to `Character`, this model defines the character's Stand, including its type, form, and coin stats (Power, Speed, Range, Durability, Precision, Development).
*   **`Heritage`**: (defined in `backend/src/characters/models.py`) Defines the character's lineage, which influences base HP and available Benefits/Detriments.
*   **`Benefit`** and **`Detriment`**: (defined in `backend/src/characters/models.py`) Represent special traits associated with a character's Heritage, impacting HP and character capabilities.
*   **`Ability`**, **`HamonAbility`**, **`SpinAbility`**: (defined in `backend/src/characters/models.py`) Represent different types of abilities a character can possess.

### 2.2. CharacterSerializer (`backend/src/characters/serializers.py`)

The `CharacterSerializer` is central to the creation and update process. It handles:

*   **Data Validation**: The `validate` method in the serializer performs crucial checks, including:
    *   **Stress/Trauma**: Ensures characters adhere to rules regarding stress levels and the accumulation of trauma. A character with 4+ trauma is considered dead.
    *   **Playbook Ability Prerequisites**: Validates that a character has sufficient 'A' ratings in their Stand's coin stats to select certain Hamon or Spin abilities.
    *   **Heritage Benefits/Detriments**: Verifies that selected Benefits and Detriments are valid for the chosen Heritage and that HP costs/gains are correctly balanced. It also ensures all required Benefits and Detriments for a given Heritage are selected.
    *   **Action Dice Advancement**: Checks that any additional action dots beyond the initial 7 are covered by sufficient XP.
    *   **Playbook XP Track Cap**: Enforces a maximum of 10 XP on the playbook track.
    *   **GM Character Locking**: Allows Game Masters to lock certain character fields (e.g., heritage, playbook) to prevent player modification, with exceptions for explicitly allowed fields.

*   **Related Object Handling**: The `create` and `update` methods manage the creation and association of related objects:
    *   **Custom Vice**: If a custom vice is provided, a new `Vice` object is created and linked to the character.
    *   **Abilities**: Handles the assignment of `standard_abilities`, `hamon_ability_ids`, and `spin_ability_ids` to the character. For Hamon and Spin abilities, it creates entries in the `CharacterHamonAbility` and `CharacterSpinAbility` junction tables.

### 2.3. Character Model Validation (`backend/src/characters/models.py`)

The `Character` model itself contains a `clean()` method that triggers several validation checks, primarily for initial character creation (level 1) and advancements:

*   **`_validate_level_1_creation()`**: A master validation method called during initial character creation. It orchestrates the following checks:
    *   **`_validate_action_dots_distribution()`**: Ensures the total number of action dots is exactly 7 for a new level 1 character, with a maximum of 2 dots per action. For characters above level 1, the maximum dots per action is 4.
    *   **`_validate_stand_coin_stats()`**: Verifies that a level 1 character has a Stand with defined coin stats, and that the total Stand Coin points sum to exactly 10. It also validates that each stat's grade is one of 'S', 'A', 'B', 'C', 'D', or 'F'.
    *   **`_validate_stress_based_on_durability()`**: Calculates the expected stress value based on the Stand's Durability grade (from 8 for 'F' to 13 for 'S') and ensures the character's stress matches this expectation.
    *   **`_validate_initial_abilities_count()`**: Confirms that a new level 1 character has exactly 3 abilities (standard, custom, or playbook).

*   **`_validate_a_rank_abilities()`**: If a Stand exists, this method validates that the total number of abilities a character possesses aligns with the number of 'A' ratings in their Stand's coin stats. Each 'A' rank grants 2 additional abilities beyond the initial 3.

*   **`_validate_xp_advancements()`**: Ensures that `total_xp_spent` is a multiple of 10 and matches the XP calculated from gained heritage points, stand coin points, and action dice. It also verifies that gained values are non-negative.

### 2.4. Character Attributes and Abilities

*   **Action Dots**: Stored in a `JSONField`, `action_dots` represent a character's proficiency in various actions (e.g., hunt, study, finesse). These are grouped into `insight`, `prowess`, and `resolve` attributes, with calculated ratings based on the number of actions with dots.
*   **Abilities**: Characters can have `standard_abilities` (many-to-many relationship with `Ability`), a `custom_ability_description`, and specific `hamon_abilities` or `spin_abilities` (through junction tables `CharacterHamonAbility` and `CharacterSpinAbility`). The `total_abilities_count` property aggregates all these.

### 2.5. Development Potential

The `Character` model includes special handling for the 'Development Potential' Stand stat, which affects XP gain and can grant temporary abilities.

*   **`development_xp_bonus`**: This read-only property on the `Character` model calculates an XP bonus based on the `development` grade of the character's `Stand`. The bonus ranges from +0 for 'F' to +5 for 'S' rank. This value is intended to be used at the end of a session to award bonus XP.

*   **`development_temporary_ability`**: This `JSONField` on the `Character` model is used to store a temporary ability. If a character's Stand has an 'A' rank in Development, they can spend 2 stress to adopt a new unique or standard ability until the end of the session, at the GM's discretion. This field provides a place to record that temporary ability.

This rigorous validation process, spanning both the serializer and the model's `clean()` method, ensures that all newly created and updated characters conform to the intricate rules of the Jojo TTRPG system.

## 3. Crew Consensus Mechanism

The Jojo TTRPG Platform implements a crew name consensus mechanism, allowing crew members to collectively decide on a new name for their crew. This process involves proposing a new name, and then requiring all other crew members to approve it before the change is finalized. The Game Master (GM) retains the ability to override this process and directly change the crew name.

### 3.1. Crew Model (`backend/src/characters/models.py`)

The `Crew` model includes specific fields to support the consensus mechanism:

*   **`name`**: The current official name of the crew.
*   **`proposed_name`**: A `CharField` that stores the new name proposed for the crew. It is `null=True` and `blank=True` when no proposal is active.
*   **`proposed_by`**: A `ForeignKey` to the `User` model, indicating which user initiated the name proposal. This is set to `null=True` when the proposal is resolved (either approved or rejected).
*   **`approved_by`**: A `ManyToManyField` to the `User` model, tracking which crew members have approved the `proposed_name`. This field is cleared when a new proposal is made or when a proposal is successfully adopted.

### 3.2. CrewViewSet (`backend/src/characters/views.py`)

The `CrewViewSet` provides the API endpoints for managing crews, including the custom actions for the consensus mechanism:

#### `propose_name` Action

*   **URL**: `/api/crews/{id}/propose-name/`
*   **Method**: `POST`
*   **Description**: Allows a crew member to propose a new name for their crew.
*   **Logic**:
    1.  Requires a `new_name` in the request data.
    2.  Verifies that the requesting user is a member of the crew.
    3.  Sets the `proposed_name` to the new name.
    4.  Sets `proposed_by` to the user who made the proposal.
    5.  **Clears** all existing approvals (`approved_by.clear()`).
    6.  Automatically adds the `proposed_by` user to the `approved_by` list, as they implicitly approve their own proposal.
    7.  Saves the `Crew` instance.

#### `approve_name` Action

*   **URL**: `/api/crews/{id}/approve-name/`
*   **Method**: `POST`
*   **Description**: Allows a crew member to approve an active name proposal.
*   **Logic**:
    1.  Checks if there is an active `proposed_name`.
    2.  Verifies that the requesting user is a member of the crew.
    3.  Adds the requesting user to the `approved_by` list if they haven't already approved.
    4.  **Consensus Check**: After an approval, the system checks if all unique members of the crew (derived from `crew.members.filter(user__isnull=False)`) have approved the `proposed_name`. This is done by comparing the set of all member user IDs with the set of user IDs in `approved_by`.
    5.  **If Consensus is Reached**:
        *   The `crew.name` is updated to the `proposed_name`.
        *   `proposed_name` is set back to `None`.
        *   `proposed_by` is set back to `None`.
        *   `approved_by` is cleared.
        *   The `Crew` instance is saved, finalizing the name change.
    6.  **If Consensus is Not Reached**: Informs the user how many more approvals are needed.

#### `perform_update` Method

*   The `perform_update` method in `CrewViewSet` handles standard PUT/PATCH requests to update a `Crew` instance.
*   **GM Override**: If the user making the request is the `Campaign`'s GM, they can directly change the `name` field without going through the consensus process.
*   **Player Restrictions**: For non-GM users, direct modification of the `name` field is prevented. Players are only allowed to modify `proposed_name`, `proposed_by`, and `approved_by` fields through the dedicated `propose_name` and `approve_name` actions, ensuring the consensus mechanism is followed.

## 4. NPC Creation and Differences from Player Characters

Non-Player Characters (NPCs) in the Jojo TTRPG Platform are designed to be flexible and easy for Game Masters (GMs) to create and manage, reflecting their role as supporting or adversarial figures rather than fully detailed player-controlled entities. While they share some commonalities with Player Characters (PCs), their data structure and creation process are streamlined.

### 4.1. NPC Model (`backend/src/characters/models.py`)

The `NPC` model contains fields tailored for GM utility and narrative purposes:

*   **Core Identity**: `name`, `level`, `appearance`, `role`.
*   **Personality & Narrative Hooks**: `weakness`, `need`, `desire`, `rumour`, `secret`, `passion`, `description`.
*   **Relationships**: `relationships` (a `JSONField` for flexible tracking of connections to other entities).
*   **Simplified Combat Tracking**: `harm_clock_current`, `vulnerability_clock_current`, `armor_charges`. These are simpler than the detailed harm levels of PCs.
*   **Calculated Properties**: `harm_clock_max`, `special_armor_charges`, and `vulnerability_clock_max` are properties that derive their values based on other NPC attributes (e.g., `stand_coin_stats`). The `special_armor_charges` property, for example, grants a number of armor charges based on the Durability grade of the NPC's Stand (from 0 for 'F' to 3 for 'S' and 'A').
*   **Stand Information**: `stand_coin_stats` (a `JSONField` for flexible Stand stat representation), `stand_description`, `stand_appearance`, `stand_manifestation`, `special_traits`.
*   **Creator and Campaign Association**: `creator` (the `User` who created the NPC) and `campaign` (the `Campaign` the NPC belongs to).
*   **Playbook**: A simple `CharField` (`playbook`) to indicate their general combat style (STAND, HAMON, SPIN), unlike the detailed ability selection for PCs.
*   **Additional GM Fields**: `purveyor`, `notes`, `items` (JSONField), `contacts` (JSONField), `faction_status` (JSONField), `inventory` (JSONField) for comprehensive GM tracking.

### 4.2. NPCSerializer (`backend/src/characters/serializers.py`)

The `NPCSerializer` handles the serialization and deserialization of NPC data:

*   It includes all fields from the `NPC` model.
*   The `creator` field is automatically set to the current authenticated user during creation (`read_only=True, default=serializers.CurrentUserDefault()`).
*   The calculated properties (`harm_clock_max`, `special_armor_charges`, `vulnerability_clock_max`) are included as `read_only` fields.

### 4.3. NPCViewSet (`backend/src/characters/views.py`)

The `NPCViewSet` provides the API endpoints for NPCs:

*   **Permissions**: Only authenticated users can create, retrieve, update, or delete NPCs.
*   **Queryset Filtering**: The `get_queryset` method ensures that users can only view NPCs they have created or NPCs that belong to campaigns they are GM of. This maintains data privacy and GM control.
*   **Automatic Creator Assignment**: The `perform_create` method automatically assigns the `creator` of the NPC to the currently authenticated user.

### 4.4. Key Differences from Player Characters

NPCs are intentionally less complex than Player Characters to facilitate quicker creation and management by GMs. The primary distinctions include:

*   **Simplified Data Model**: NPCs have a flatter data structure. For instance, their Stand stats are stored in a flexible `JSONField` (`stand_coin_stats`), whereas PCs have a dedicated `Stand` model with individual fields for each stat and associated validation.
*   **No Complex Validation Logic**: Unlike PCs, NPCs do not undergo the rigorous validation checks for action dot distribution, XP advancements, or detailed ability prerequisites. Their creation is more free-form, allowing GMs to quickly define them as needed for the narrative.
*   **GM-Centric Fields**: NPCs include fields like `role`, `weakness`, `need`, `desire`, `rumour`, `secret`, `passion`, `relationships`, `purveyor`, `notes`, `items`, `contacts`, `faction_status`, and `inventory` that are primarily for GM use in developing the game world and story, and are not present on player characters.
*   **Harm Tracking**: NPCs use a simpler harm clock system, while PCs have a more granular system of named harm levels.
*   **Ability Selection**: NPCs have a simple `playbook` choice, while PCs have detailed mechanisms for selecting standard, Hamon, and Spin abilities, often with prerequisites tied to their Stand's A-rank stats.
*   **No Direct XP/Advancement Tracking**: NPCs do not have the detailed XP clocks, total XP spent, or advancement tracking fields that are central to PC progression. Their power level (`level`) is typically set directly by the GM.

These differences reflect the distinct roles of PCs (player-controlled, detailed progression) and NPCs (GM-controlled, narrative-focused) within the game system.

## 5. Testing Strategy

The Jojo TTRPG Platform backend employs a comprehensive testing strategy to ensure the reliability, correctness, and adherence to game rules of its various components. The tests are primarily unit and integration tests, focusing on individual models, serializers, and views, as well as their interactions.

### 5.1. Test Framework

Tests are written using Django's built-in `TestCase` class, which provides a testing environment that includes a separate database for each test, ensuring isolation and preventing side effects.

### 5.2. Test File Locations

Test files are located within the `tests` subdirectories of their respective Django applications. For the `characters` app, tests are found in `backend/src/characters/tests/`.

### 5.3. Key Test Areas

*   **Model Validation**: Tests extensively cover the custom validation logic implemented in Django models (e.g., `Character.clean()`) and serializers (e.g., `CharacterSerializer.validate()`). These tests are crucial for enforcing SRD rules and data integrity.
*   **API Endpoints**: Tests verify the behavior of API endpoints, ensuring they return the correct data, handle invalid input gracefully, and enforce proper permissions.
*   **Game Mechanics**: Specific tests are in place to validate the implementation of core game mechanics, such as character advancement, stress/trauma tracking, and ability interactions.

### 5.4. Specific Test Files

As identified, the main test files for the `characters` app are:

*   **`test_pc_validation.py`**: Focuses on the validation rules for Player Characters, covering aspects like action dot distribution, Stand Coin stats, stress calculation, and ability counts. This file is particularly important for ensuring new and updated characters conform to the SRD.
*   **`test_crew_name_consensus.py`**: Verifies the functionality of the crew name consensus mechanism, including proposing names, approving them, and the final name change upon consensus.
*   **`test_npc_validation.py`**: Contains tests for Non-Player Character validation, ensuring that NPCs are created and managed according to their simplified rules.

For a more detailed explanation of how tests relate to the Standard Reference Document (SRD) and enforce its rules, please refer to the [SRD Integration](../SRD_INTEGRATION.md) document.

### 5.5. Running Tests

Tests can typically be run using Django's `manage.py` command:

```bash
python manage.py test characters
```

This command will execute all tests within the `characters` application. Specific test files or test cases can also be run by providing their path or name to the `test` command.

## 6. API Endpoints

The Jojo TTRPG Platform backend exposes a comprehensive set of RESTful API endpoints to manage game data, characters, campaigns, and game mechanics. These endpoints are built using Django REST Framework (DRF) and follow standard HTTP methods (GET, POST, PUT, PATCH, DELETE) for resource manipulation.

### 6.1. Authentication

All API endpoints (except for user registration and login) require authentication. The system uses **Token Authentication**.

*   **`/api/accounts/signup/` (POST)**: Register a new user.
*   **`/api/accounts/login/` (POST)**: Authenticate a user and obtain an authentication token.

### 6.2. Core Game Data Endpoints

These endpoints provide access to static or reference game data, often populated from SRD fixtures.

*   **`/api/heritages/` (GET)**: Retrieve a list of all available Heritages, including their associated Benefits and Detriments.
*   **`/api/vices/` (GET)**: Retrieve a list of all available Vices.
*   **`/api/abilities/` (GET)**: Retrieve a list of standard Abilities.
*   **`/api/stand-abilities/` (GET)**: Retrieve a list of Stand-specific Abilities.
*   **`/api/hamon-abilities/` (GET)**: Retrieve a list of Hamon-specific Abilities.
*   **`/api/spin-abilities/` (GET)**: Retrieve a list of Spin-specific Abilities.
*   **`/api/traumas/` (GET)**: Retrieve a list of Trauma types.

### 6.3. Character Management Endpoints

These endpoints are used for creating, retrieving, updating, and managing player characters.

*   **`/api/characters/` (GET, POST)**: List all characters accessible to the authenticated user (their own characters, or all characters in campaigns they GM), or create a new character.
*   **`/api/characters/{id}/` (GET, PUT, PATCH, DELETE)**: Retrieve, update, or delete a specific character by its ID.
*   **`/api/characters/creation-guide/` (GET)**: Provides a comprehensive guide to character creation, including available options (heritages, abilities, vices) and rules (action dots, coin stats).
*   **`/api/characters/{id}/update-field/` (PATCH)**: Allows for real-time, granular updates to individual character fields with immediate validation. This is used for interactive character sheet editing.

### 6.4. Game Mechanics Endpoints

These endpoints facilitate interactive game mechanics and character actions.

*   **`/api/characters/{id}/roll-action/` (POST)**: Simulate a dice roll for a character action, considering action dots, attribute dice, position (controlled, risky, desperate), and effect (limited, standard, great).
*   **`/api/characters/{id}/indulge-vice/` (POST)**: Allows a character to indulge their vice to reduce stress, recording the activity as a Downtime Activity.
*   **`/api/characters/{id}/take-harm/` (POST)**: Records harm taken by a character at a specific level (1-4).
*   **`/api/characters/{id}/heal-harm/` (POST)**: Heals a specific level of harm and advances the character's healing clock.

### 6.5. Progression and Tracking Endpoints

These endpoints manage character advancement and various in-game tracking mechanisms.

*   **`/api/characters/{id}/add-xp/` (POST)**: Adds experience points to a character's specific XP tracks (insight, prowess, resolve, heritage, playbook).
*   **`/api/characters/{id}/add-progress-clock/` (POST)**: Creates a new progress clock associated with a character (e.g., for long-term projects, healing, or custom tracking).
*   **`/api/characters/{id}/update-progress-clock/` (POST)**: Updates the filled segments of an existing progress clock.

### 6.6. Campaign and Crew Management Endpoints

These endpoints are used by GMs and players to manage campaigns, crews, and NPCs.

*   **`/api/campaigns/` (GET, POST, PUT, PATCH, DELETE)**: Manage game campaigns. GMs can create and edit campaigns, while players can view campaigns they are part of.
*   **`/api/crews/` (GET, POST, PUT, PATCH, DELETE)**: Manage crews. Includes custom actions for the crew name consensus mechanism.
    *   **`/api/crews/{id}/propose-name/` (POST)**: Propose a new name for a crew.
    *   **`/api/crews/{id}/approve-name/` (POST)**: Approve a proposed crew name.
*   **`/api/npcs/` (GET, POST, PUT, PATCH, DELETE)**: Manage Non-Player Characters. GMs can create and edit NPCs within their campaigns.

### 6.7. Search Endpoint

*   **`/api/search/` (GET)**: A global search endpoint that allows users to search across various game entities (characters, campaigns, NPCs, abilities, heritages) using a single query parameter (`q`).

This comprehensive set of API endpoints provides the necessary interface for the frontend application to interact with the backend and manage all aspects of the Jojo TTRPG game.
